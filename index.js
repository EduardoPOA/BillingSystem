// ü§ñ BOT AUTOM√ÅTICO COM GOOGLE SHEETS
// Personal s√≥ escaneia QR Code e cola URL da planilha

import makeWASocket, { useMultiFileAuthState, fetchLatestBaileysVersion, DisconnectReason, makeCacheableSignalKeyStore } from '@whiskeysockets/baileys';
import express from 'express';
import bodyParser from 'body-parser';
import fs from 'fs';
import QRCode from 'qrcode';
import https from 'https';
import cron from 'node-cron';

const app = express();
app.use(bodyParser.json());

const clientBots = new Map();

// üîπ Fun√ß√£o para ler Google Sheets p√∫blico
async function readPublicSheet(sheetUrl) {
  try {
    // Extrai o ID da planilha
    const sheetId = sheetUrl.match(/\/d\/([a-zA-Z0-9-_]+)/)?.[1];
    if (!sheetId) throw new Error('URL da planilha inv√°lida');
    
    // URL da API do Google Sheets (formato CSV p√∫blico)
    const csvUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv`;
    
    return new Promise((resolve, reject) => {
      https.get(csvUrl, (res) => {
        let data = '';
        res.on('data', chunk => data += chunk);
        res.on('end', () => {
          // Parseia CSV para array
          const lines = data.split('\n');
          const headers = lines[0].split(',');
          const rows = [];
          
          for (let i = 1; i < lines.length; i++) {
            if (!lines[i].trim()) continue;
            const values = lines[i].split(',');
            const row = {};
            headers.forEach((header, index) => {
              row[header.trim()] = values[index]?.trim() || '';
            });
            rows.push(row);
          }
          
          resolve(rows);
        });
      }).on('error', reject);
    });
  } catch (error) {
    console.error('‚ùå Erro ao ler planilha:', error);
    throw error;
  }
}

// üîπ Processar pagamentos de um cliente
async function processarPagamentos(clientId) {
  const client = clientBots.get(clientId);
  if (!client || !client.connected || !client.sheetUrl) return;
  
  try {
    console.log(`üîÑ Processando pagamentos para ${clientId}`);
    
    const alunos = await readPublicSheet(client.sheetUrl);
    const hoje = new Date();
    hoje.setHours(0, 0, 0, 0);
    
    for (const aluno of alunos) {
      // Adaptar aos nomes reais da planilha
      const nome = aluno.Nome || aluno.nome || aluno.Aluno || aluno.aluno;
      const telefone = aluno.Telefone || aluno.telefone || aluno.Celular || aluno.celular;
      const dataVenc = aluno.Data_Vencimento || aluno.data_vencimento || aluno.Vencimento || aluno.vencimento;
      const valor = aluno.Valor || aluno.valor || '0';
      const status = aluno.Status_Pagamento || aluno.status_pagamento || 'Pendente';
      
      if (!nome || !telefone || !dataVenc || status === 'Pago') continue;
      
      // Converte data (formato DD/MM/AAAA)
      const [dia, mes, ano] = dataVenc.split('/');
      const dataVencimento = new Date(ano, mes - 1, dia);
      dataVencimento.setHours(0, 0, 0, 0);
      
      // Calcula dias
      const diffDays = Math.ceil((dataVencimento - hoje) / (1000 * 60 * 60 * 24));
      
      let mensagem = '';
      const valorFormatado = valor ? `R$ ${parseFloat(valor).toFixed(2).replace('.', ',')}` : 'N/A';
      const chavePix = client.chavePix || 'N√£o configurado';
      
      // L√≥gica de envio
      if (diffDays < 0) {
        // Atrasado
        const diasAtraso = Math.abs(diffDays);
        mensagem = `Ol√° ${nome}! ‚ö†Ô∏è\n\nSeu pagamento est√° atrasado h√° ${diasAtraso} dia(s).\n\nüí∞ Valor: ${valorFormatado}\nüìÖ Vencimento: ${dataVenc}\n\nüí≥ PIX:\n${chavePix}\n\nPor favor, regularize sua situa√ß√£o! üí™`;
      } else if (diffDays === 0) {
        // Vence hoje
        mensagem = `Ol√° ${nome}! üî¥\n\nSeu pagamento vence HOJE!\n\nüí∞ Valor: ${valorFormatado}\nüìÖ Vencimento: ${dataVenc}\n\nüí≥ PIX:\n${chavePix}\n\nRealize o pagamento para evitar bloqueio! üí™`;
      } else if (diffDays === 3) {
        // 3 dias antes
        mensagem = `Ol√° ${nome}! üîî\n\nSeu pagamento vence em 3 dias.\n\nüí∞ Valor: ${valorFormatado}\nüìÖ Vencimento: ${dataVenc}\n\nüí≥ PIX:\n${chavePix}\n\nFique em dia! üí™`;
      }
      
      if (mensagem) {
        await enviarMensagem(clientId, telefone, mensagem);
        await new Promise(resolve => setTimeout(resolve, 2000)); // Delay
      }
    }
    
    console.log(`‚úÖ Processamento conclu√≠do para ${clientId}`);
  } catch (error) {
    console.error(`‚ùå Erro ao processar ${clientId}:`, error);
  }
}

// üîπ Enviar mensagem
async function enviarMensagem(clientId, phone, message) {
  const client = clientBots.get(clientId);
  if (!client || !client.connected) return false;
  
  try {
    let cleanPhone = phone.replace(/\D/g, '');
    
    // Adiciona 9 no celular se necess√°rio (BR)
    if (cleanPhone.startsWith('55') && cleanPhone.length === 12) {
      const countryCode = cleanPhone.substring(0, 2);
      const ddd = cleanPhone.substring(2, 4);
      const number = cleanPhone.substring(4);
      cleanPhone = countryCode + ddd + '9' + number;
    }
    
    const formattedPhone = cleanPhone + '@c.us';
    await client.sock.sendMessage(formattedPhone, { text: message });
    
    console.log(`‚úÖ [${clientId}] Mensagem enviada para ${phone}`);
    return true;
  } catch (error) {
    console.error(`‚ùå [${clientId}] Erro:`, error);
    return false;
  }
}

// üîπ Criar bot do cliente
async function createClientBot(clientId) {
  try {
    const authPath = `./clients/${clientId}/auth`;
    if (!fs.existsSync(authPath)) {
      fs.mkdirSync(authPath, { recursive: true });
    }

    const { state, saveCreds } = await useMultiFileAuthState(authPath);
    const { version } = await fetchLatestBaileysVersion();
    
    const sock = makeWASocket({
      version,
      auth: {
        creds: state.creds,
        keys: makeCacheableSignalKeyStore(state.keys, console),
      },
      printQRInTerminal: false,
    });

    sock.ev.on('creds.update', saveCreds);

    sock.ev.on('connection.update', async (update) => {
      const { connection, lastDisconnect, qr } = update;

      if (qr) {
        const qrImage = await QRCode.toDataURL(qr);
        const client = clientBots.get(clientId);
        if (client) {
          client.qrCode = qrImage;
        }
        console.log(`üì∑ QR Code gerado para ${clientId}`);
      }

      if (connection === 'close') {
        const shouldReconnect = lastDisconnect?.error?.output?.statusCode !== DisconnectReason.loggedOut;
        if (shouldReconnect) {
          console.log(`üîÑ Reconectando ${clientId}`);
          setTimeout(() => createClientBot(clientId), 3000);
        }
      } else if (connection === 'open') {
        const client = clientBots.get(clientId);
        const connectedNumber = sock.user.id.split(':')[0];
        
        console.log(`‚úÖ ${clientId} conectado! N√∫mero: ${connectedNumber}`);
        
        if (client) {
          client.connected = true;
          client.connectedNumber = connectedNumber;
          client.qrCode = null;
          
          // Salva informa√ß√µes
          saveClientData(clientId);
        }
      }
    });

    clientBots.set(clientId, {
      sock,
      connected: false,
      qrCode: null,
      sheetUrl: null,
      chavePix: null,
      createdAt: new Date(),
    });

    return sock;
  } catch (error) {
    console.error(`‚ùå Erro ao criar bot para ${clientId}:`, error);
    throw error;
  }
}

// üîπ Salvar dados do cliente
function saveClientData(clientId) {
  const client = clientBots.get(clientId);
  if (!client) return;
  
  const clientDir = `./clients/${clientId}`;
  if (!fs.existsSync(clientDir)) {
    fs.mkdirSync(clientDir, { recursive: true });
  }
  
  const data = {
    id: clientId,
    connectedNumber: client.connectedNumber,
    sheetUrl: client.sheetUrl,
    chavePix: client.chavePix,
    connected: client.connected,
    createdAt: client.createdAt,
  };
  
  fs.writeFileSync(`${clientDir}/config.json`, JSON.stringify(data, null, 2));
}

// üîπ Carregar clientes existentes
async function loadExistingClients() {
  const clientsDir = './clients';
  if (!fs.existsSync(clientsDir)) {
    fs.mkdirSync(clientsDir, { recursive: true });
    return;
  }

  const clients = fs.readdirSync(clientsDir);
  
  for (const clientId of clients) {
    const configPath = `${clientsDir}/${clientId}/config.json`;
    if (fs.existsSync(configPath)) {
      const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
      console.log(`üîÑ Carregando cliente: ${clientId}`);
      
      await createClientBot(clientId);
      
      const client = clientBots.get(clientId);
      if (client) {
        client.sheetUrl = config.sheetUrl;
        client.chavePix = config.chavePix;
      }
    }
  }
}

// üîπ P√°gina inicial (Cadastro/Conex√£o)
app.get('/', (req, res) => {
  res.send(`
<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sistema de Cobran√ßa Autom√°tica</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    .container {
      background: white;
      border-radius: 20px;
      padding: 40px;
      max-width: 500px;
      width: 100%;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      text-align: center;
    }
    h1 { color: #25D366; margin-bottom: 10px; }
    .subtitle { color: #666; margin-bottom: 30px; }
    .qr-container {
      background: #f5f5f5;
      padding: 20px;
      border-radius: 15px;
      margin: 20px 0;
      min-height: 300px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #qrCode { max-width: 280px; width: 100%; }
    .loading { color: #667eea; }
    .form-group {
      margin: 20px 0;
      text-align: left;
    }
    label {
      display: block;
      color: #555;
      margin-bottom: 8px;
      font-weight: 500;
    }
    input {
      width: 100%;
      padding: 12px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 14px;
    }
    input:focus {
      outline: none;
      border-color: #667eea;
    }
    .btn {
      background: #25D366;
      color: white;
      border: none;
      padding: 15px 30px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      width: 100%;
      margin-top: 10px;
    }
    .btn:hover { background: #128C7E; }
    .btn:disabled { background: #ccc; cursor: not-allowed; }
    .status {
      padding: 15px;
      border-radius: 10px;
      margin-top: 20px;
      font-weight: 500;
    }
    .status.connected { background: #d4edda; color: #155724; }
    .status.waiting { background: #fff3cd; color: #856404; }
    .info-box {
      background: #e7f3ff;
      padding: 15px;
      border-radius: 10px;
      margin-top: 20px;
      text-align: left;
      font-size: 14px;
      color: #004085;
    }
    .info-box strong { display: block; margin-bottom: 5px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>ü§ñ Sistema de Cobran√ßa</h1>
    <p class="subtitle">Configure em 3 passos</p>
    
    <div class="qr-container">
      <img id="qrCode" style="display:none;" alt="QR Code">
      <div class="loading" id="loading">‚è≥ Gerando QR Code...</div>
    </div>
    
    <div id="status" class="status waiting">
      ‚è≥ Aguardando conex√£o WhatsApp...
    </div>
    
    <div class="form-group" id="formGroup" style="display:none;">
      <label>üìä URL da sua Planilha Google Sheets:</label>
      <input type="text" id="sheetUrl" placeholder="https://docs.google.com/spreadsheets/d/...">
      
      <label style="margin-top:15px;">üí≥ Sua Chave PIX:</label>
      <input type="text" id="chavePix" placeholder="email@pix.com ou CPF">
      
      <button class="btn" onclick="salvarConfig()">‚úÖ Ativar Sistema</button>
    </div>
    
    <div class="info-box" style="display:none;" id="infoBox">
      <strong>‚úÖ Sistema Ativado!</strong>
      Todo dia √†s 9h da manh√£, o sistema vai verificar sua planilha e enviar mensagens automaticamente.
    </div>
    
    <script>
      const clientId = 'client-' + Math.random().toString(36).substr(2, 9);
      let checkInterval;
      
      async function init() {
        // Cria o cliente
        await fetch('/api/setup', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({ clientId })
        });
        
        // Inicia verifica√ß√£o
        checkInterval = setInterval(checkStatus, 2000);
        checkStatus();
      }
      
      async function checkStatus() {
        try {
          const res = await fetch('/api/status/' + clientId);
          const data = await res.json();
          
          if (data.qrCode && !data.connected) {
            document.getElementById('qrCode').src = data.qrCode;
            document.getElementById('qrCode').style.display = 'block';
            document.getElementById('loading').style.display = 'none';
          }
          
          if (data.connected) {
            document.getElementById('status').className = 'status connected';
            document.getElementById('status').textContent = '‚úÖ WhatsApp conectado!';
            document.getElementById('formGroup').style.display = 'block';
            clearInterval(checkInterval);
          }
        } catch (error) {
          console.error('Erro:', error);
        }
      }
      
      async function salvarConfig() {
        const sheetUrl = document.getElementById('sheetUrl').value;
        const chavePix = document.getElementById('chavePix').value;
        
        if (!sheetUrl || !chavePix) {
          alert('Por favor, preencha todos os campos');
          return;
        }
        
        try {
          const res = await fetch('/api/config', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ clientId, sheetUrl, chavePix })
          });
          
          const data = await res.json();
          
          if (data.success) {
            document.getElementById('formGroup').style.display = 'none';
            document.getElementById('infoBox').style.display = 'block';
          } else {
            alert('Erro: ' + data.error);
          }
        } catch (error) {
          alert('Erro ao salvar configura√ß√£o');
        }
      }
      
      init();
    </script>
  </body>
</html>
  `);
});

// üîπ API: Setup inicial
app.post('/api/setup', async (req, res) => {
  const { clientId } = req.body;
  
  try {
    if (!clientBots.has(clientId)) {
      await createClientBot(clientId);
    }
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// üîπ API: Status
app.get('/api/status/:clientId', (req, res) => {
  const { clientId } = req.params;
  const client = clientBots.get(clientId);
  
  if (!client) {
    return res.status(404).json({ success: false, error: 'Cliente n√£o encontrado' });
  }
  
  res.json({
    success: true,
    connected: client.connected,
    qrCode: client.qrCode,
    hasConfig: !!(client.sheetUrl && client.chavePix),
  });
});

// üîπ API: Salvar configura√ß√£o
app.post('/api/config', (req, res) => {
  const { clientId, sheetUrl, chavePix } = req.body;
  
  const client = clientBots.get(clientId);
  if (!client) {
    return res.status(404).json({ success: false, error: 'Cliente n√£o encontrado' });
  }
  
  if (!client.connected) {
    return res.status(400).json({ success: false, error: 'WhatsApp n√£o conectado' });
  }
  
  client.sheetUrl = sheetUrl;
  client.chavePix = chavePix;
  
  saveClientData(clientId);
  
  res.json({ success: true, message: 'Configura√ß√£o salva com sucesso!' });
});

// üîπ Cron job: Roda todo dia √†s 9h
cron.schedule('0 9 * * *', () => {
  console.log('‚è∞ Iniciando verifica√ß√£o di√°ria de pagamentos...');
  clientBots.forEach((client, clientId) => {
    if (client.connected && client.sheetUrl) {
      processarPagamentos(clientId);
    }
  });
});

// üîπ API: Processar manualmente (teste)
app.post('/api/process/:clientId', async (req, res) => {
  const { clientId } = req.params;
  
  try {
    await processarPagamentos(clientId);
    res.json({ success: true, message: 'Processamento conclu√≠do' });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// üîπ Iniciar servidor
const PORT = process.env.PORT || 3000;
app.listen(PORT, async () => {
  console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
  console.log('‚ïë   ü§ñ SISTEMA DE COBRAN√áA AUTOM√ÅTICO   ‚ïë');
  console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
  console.log(`\nüöÄ Acesse: http://localhost:${PORT}\n`);
  
  await loadExistingClients();
  console.log('‚úÖ Sistema pronto!\n');
});